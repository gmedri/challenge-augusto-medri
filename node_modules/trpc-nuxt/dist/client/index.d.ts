import * as _trpc_client from '@trpc/client';
import { TRPCClientErrorLike, TRPCRequestOptions as TRPCRequestOptions$1, HTTPLinkOptions as HTTPLinkOptions$1, HTTPBatchLinkOptions, CreateTRPCClientOptions } from '@trpc/client';
import { ProcedureRouterRecord, AnyRouter, AnyProcedure, AnyQueryProcedure, inferProcedureInput, AnyMutationProcedure, AnySubscriptionProcedure, ProcedureArgs, inferProcedureOutput, DeepPartial } from '@trpc/server';
import { inferObservableValue, Unsubscribable } from '@trpc/server/observable';
import { inferTransformedProcedureOutput } from '@trpc/server/shared';
import { AsyncDataOptions, AsyncData } from 'nuxt/app';
import { MaybeRefOrGetter, UnwrapRef } from 'vue';

type PickFrom<T, K extends Array<string>> = T extends Array<any> ? T : T extends Record<string, any> ? keyof T extends K[number] ? T : K[number] extends never ? T : Pick<T, K[number]> : T;
type KeysOf<T> = Array<T extends T ? keyof T extends string ? keyof T : never : never>;
type TRPCSubscriptionObserver<TValue, TError> = {
    onStarted: () => void;
    onData: (value: TValue) => void;
    onError: (err: TError) => void;
    onStopped: () => void;
    onComplete: () => void;
};
interface TRPCRequestOptions extends TRPCRequestOptions$1 {
    abortOnUnmount?: boolean;
}
type Resolver<TProcedure extends AnyProcedure> = (...args: ProcedureArgs<TProcedure['_def']>) => Promise<inferTransformedProcedureOutput<TProcedure>>;
type SubscriptionResolver<TProcedure extends AnyProcedure, TRouter extends AnyRouter> = (...args: [
    input: ProcedureArgs<TProcedure['_def']>[0],
    opts: ProcedureArgs<TProcedure['_def']>[1] & Partial<TRPCSubscriptionObserver<inferObservableValue<inferProcedureOutput<TProcedure>>, TRPCClientErrorLike<TRouter>>>
]) => Unsubscribable;
type DecorateProcedure<TProcedure extends AnyProcedure, TRouter extends AnyRouter> = TProcedure extends AnyQueryProcedure ? {
    useQuery: <ResT = inferTransformedProcedureOutput<TProcedure>, DataE = TRPCClientErrorLike<TProcedure>, DataT = ResT, PickKeys extends KeysOf<DataT> = KeysOf<DataT>, DefaultT = null>(input: MaybeRefOrGetter<inferProcedureInput<TProcedure>>, opts?: Omit<AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>, 'watch'> & {
        trpc?: TRPCRequestOptions;
        /**
         * The custom unique key to use.
         * @see https://nuxt.com/docs/api/composables/use-async-data#params
         */
        queryKey?: string;
        watch?: AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>['watch'] | false;
    }) => AsyncData<PickFrom<DataT, PickKeys> | DefaultT, DataE>;
    useLazyQuery: <ResT = inferTransformedProcedureOutput<TProcedure>, DataE = TRPCClientErrorLike<TProcedure>, DataT = ResT, PickKeys extends KeysOf<DataT> = KeysOf<DataT>, DefaultT = null>(input: MaybeRefOrGetter<inferProcedureInput<TProcedure>>, opts?: Omit<AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>, 'lazy' | 'watch'> & {
        trpc?: TRPCRequestOptions;
        /**
         * The custom unique key to use.
         * @see https://nuxt.com/docs/api/composables/use-async-data#params
         */
        queryKey?: string;
        watch?: AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>['watch'] | false;
    }) => AsyncData<PickFrom<DataT, PickKeys> | DefaultT, DataE>;
    query: Resolver<TProcedure>;
} : TProcedure extends AnyMutationProcedure ? {
    mutate: Resolver<TProcedure>;
    useMutation: <ResT = inferTransformedProcedureOutput<TProcedure>, DataE = TRPCClientErrorLike<TProcedure>, DataT = ResT, PickKeys extends KeysOf<DataT> = KeysOf<DataT>, DefaultT = null>(opts?: Omit<AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>, 'lazy'> & {
        trpc?: TRPCRequestOptions;
    }) => AsyncData<PickFrom<DataT, PickKeys> | DefaultT, DataE> & {
        /**
         * The function to call to trigger the mutation.
         */
        mutate: (input: inferProcedureInput<TProcedure>) => Promise<UnwrapRef<AsyncData<PickFrom<DataT, PickKeys> | null, DataE>['data']>>;
    };
} : TProcedure extends AnySubscriptionProcedure ? {
    subscribe: SubscriptionResolver<TProcedure, TRouter>;
} : never;
/**
* @internal
*/
type DecoratedProcedureRecord<TProcedures extends ProcedureRouterRecord, TRouter extends AnyRouter> = {
    [TKey in keyof TProcedures]: TProcedures[TKey] extends AnyRouter ? DecoratedProcedureRecord<TProcedures[TKey]['_def']['record'], TRouter> : TProcedures[TKey] extends AnyProcedure ? DecorateProcedure<TProcedures[TKey], TRouter> : never;
};

type GetQueryParams<TProcedureOrRouter extends AnyQueryProcedure, TProcedureInput = inferProcedureInput<TProcedureOrRouter>> = DeepPartial<TProcedureInput>;
type GetParams<TProcedureOrRouter extends AnyQueryProcedure> = [
    procedureOrRouter: DecorateProcedure<TProcedureOrRouter, AnyRouter> | string,
    params: GetQueryParams<TProcedureOrRouter>
];
type GetQueryKeyParams<TProcedureOrRouter extends AnyQueryProcedure> = GetParams<TProcedureOrRouter>;
/**
 * Method to extract the query key for a procedure
 * @param procedure - procedure
 * @param input - input to procedure
 * @link https://trpc-nuxt.vercel.app/get-started/tips/mutation
 */
declare function getQueryKey<TProcedure extends AnyQueryProcedure>(..._params: GetQueryKeyParams<TProcedure>): string;

interface HTTPLinkOptions extends HTTPLinkOptions$1 {
    /**
     * Select headers to pass to `useRequestHeaders`.
     */
    pickHeaders?: string[];
}
/**
 * This is a convenience wrapper around the original httpLink
 * that replaces regular `fetch` with a `$fetch` from Nuxt. It
 * also sets the default headers based on `useRequestHeaders` values.
 *
 * During server-side rendering, calling $fetch to fetch your internal API routes
 * will directly call the relevant function (emulating the request),
 * saving an additional API call.
 *
 * @see https://nuxt.com/docs/api/utils/dollarfetch
 */
declare function httpLink<TRouter extends AnyRouter>(opts?: HTTPLinkOptions): _trpc_client.TRPCLink<TRouter>;
interface HttpBatchLinkOptions extends HTTPBatchLinkOptions {
    /**
     * Select headers to pass to `useRequestHeaders`.
     */
    pickHeaders?: string[];
}
/**
 * This is a convenience wrapper around the original httpBatchLink
 * that replaces regular `fetch` with a `$fetch` from Nuxt. It
 * also sets the default headers based on `useRequestHeaders` values.
 *
 * During server-side rendering, calling $fetch to fetch your internal API routes
 * will directly call the relevant function (emulating the request),
 * saving an additional API call.
 *
 * @see https://nuxt.com/docs/api/utils/dollarfetch
 */
declare function httpBatchLink<TRouter extends AnyRouter>(opts?: HttpBatchLinkOptions): _trpc_client.TRPCLink<TRouter>;

declare function createTRPCNuxtClient<TRouter extends AnyRouter>(opts: CreateTRPCClientOptions<TRouter>): DecoratedProcedureRecord<TRouter["_def"]["record"], TRouter>;

export { createTRPCNuxtClient, getQueryKey, httpBatchLink, httpLink };
